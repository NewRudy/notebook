# 深入浅出nodejs

以前粗略的看过一遍，现在希望能认真的过一遍

## 1. Node 简介

JavaScript 已经不是一门玩具（脚本）语言了，它正在通过 Node.js 进军所有领域，过去因为前后端语言的不同而分散的知识点，通过 Node 也可以重新组合连接起来

### 1.1 Node 的历史

JavaScript 从 Brenden Eich 刚开始设计的时候就有了函数编程、原型链继承等特点，并且在服务端已经尝试过了，但是在服务端的性能很烂。最终 20008 年 V8 引擎的诞生给JavaScript带来了较高的性能，同时 Ryan Dahl 也想要设计一个高性能 Web 服务器（事件驱动，异步 I/O），最终大佬 凭借 V8 引擎和异步 I/O 模型创造出了 Node

### 1.2 为什么叫Node

Node 已经发展成为一个强制不共享任何资源的单线程、单进程系统，包含十分适宜网络的库，为构建大型分布式应用程序提供基础设施，其目标也是成为一个构建快速、可伸缩的网络应用平台。它自身非常简单，通过通信协议来组织许多的 Node 进程，非常容易通过横向扩展来达成构建大型网络应用的目的。每一个 Node 进程都构成这个网络应用中的一个节点，这也是 Node 这个名字的真谛

### 1.3 Node 给 JavaScript 带来的意义

![chrome 和 Node 的组件构成](../image/chrome%20%E5%92%8C%20Node%20%E7%9A%84%E7%BB%84%E4%BB%B6%E6%9E%84%E6%88%90-16577252684151.png)

除了 HTML、WebKit和显卡这些 UI 相关技术之外，Node 的结构和 Chrome 十分相似。它们都是基于事件驱动的异步架构，浏览器通过事件驱动来服务界面上的交互，Node 通过事件驱动来服务 I/O

前后端编程环境统一，可以大大降低前后端转换所需要的上下文的交换代价（服务端渲染需要的同构）

Node 的特点有：异步 I/O、事件与回调函数、单线程、跨平台

### 1.4 异步 I/O

类似与 Ajax 一样去进行文件的 I/O，node 在底层构建了许多的异步 I/O 的 API，从文件读取到网络请求等，这样我们可以从语言的层面就很自然的进行并行 I/O 操作

### 1.5 事件与回调函数

事件的编程方式具有轻量级、松耦合、只关注事物等特点，但是在多个异步任务的场景下，事件与事件之间如何独立，又如何协作是一个问题，并且事件发生异常应该如何有效处理

与其它的 Web 后端编程语言相比，Node 除了异步和事件外，回调函数是一大特点，回调函数也是最好的接收异步调用返回数据的方式

### 1.6 单线程

Node 保持了 JavaScript 在浏览器中单线程的特点。而且在 Node 中，JavaScript 与其余线程是无法共享任何状态的。单线程最大好处是不用像多线程编程那样处处在意状态的同步问题，也没有死锁的存在，但是单线程也带来了 3 方面的弱点：

- 无法利用多核 CPU
- 错误会引起整个应用退出
- 大量占用 CPU 导致无法继续调用异步 I/O

像浏览器中 JavaScript 与 UI 共用一个线程一样，JavaScript 长时间执行会导致 UI 的渲染和响应被中断。在 Node 中，长时间的的 CPU 占用也会导致后续的异步 I/O 发不出调用，已完成的异步 I/O 的回调函数也会得不到及时执行。浏览器的解决办法是 HTML5 中定制的 Web Workers 标准，Web Workers 能够创建工作线程来进行计算，已解决 JavaScript 大计算阻塞 UI 渲染的问题。工作线程为了不阻塞主线程，通过以消息传递的方式来传递运行结果，这也使得工作线程不能访问主线程的 UI

同理，Node 采用了与 Web Workers 相同的思路来解决单线程中大计算量的问题：child_process。子进程的出现，意味着 Node 可以从容地应对单线程在健壮性和无法利用多核 CPU 方面的问题。通过将计算分发到各个子进程，可以将大量计算分解掉，然后再通过进程之间的事件消息来传递结果，这可以很好地保持应用模型的简单和低依赖

### 1.7 应用场景

Node 面向网络且擅长并行 I/O，优势在于 Node 利用事件循环的处理能力，而不是启动每一个线程为每一个请求服务，资源占用极小

CPU 密集型应用给 Node 带来的挑战主要是：由于 JavaScript 单线程的原因，如果有长时间运行的计算（比如大循环），将会导致 CPU 时间片不能释放，导致后续 I/O 无法发起，但是如果能适当调整和分解大型运算任务为多个小任务，使得运算能够适时释放，不阻塞 I/O 的发起，这样就可以既享受到并行异步 I/O 的好处，又能充分利用 CPU（类似与 CPU 时间分片的方式）

下段引用自 [浏览器渲染机制](https://www.cnblogs.com/panshaojun/p/14976728.html)

在避免 JavaScript 连续触发 Layout 时，也是采用了这种类似 CPU 时间分片的方式，JavaScript 涉及到 Layout 的操作时，会触发 Layout，此时 JavaScript 任务挂起，Layout 完毕再继续 JavaScript 操作，如果这种操作大量连续出现，会造成页面卡顿（因为 Layout 很费时，导致 Render Tree 得不到及时的更新），解决办法是将一系列的操作分解成一个个合适的操作（合适的意思是，该操作的花费总和少于一个固定的时间），再某段时间只执行一个，通用的是采用 setTimeout 实现，不过 setTimeout 有一个弊端，因为 JavaScript 是单线程，如果 JavaScript 的运行时间超过了 setTimeout 的时间，将会导致 setTimeout 得不到及时的处理，Render Tree 照样得不到及时更新（解决办法是 window.requestAnimationFrame 解决了 setTimeout 的弊端，这个接口会在下一帧绘制前调用，保证时间的一致性）

## 2. 模块机制

### 2.1  JS 先天就缺乏模块

JavaScript 刚开始只是一个脚本语言，但是随着需要，大致经历了：工具类库（浏览器兼容）、组件库（功能模块：Jquery，Lodash）、框架（功能模块组织：gulp，RequireJS，Less）、应用（业务模块组织：Vue，React，Angular）

JavaScript 不断被类聚和抽象，以更好地组织业务逻辑，从另一个角度而言，他也道出了 JavaScript 先天就缺乏的一项功能：模块

web1.0 时代，只有对 DOM、BOM 等基本支持，但是随着 Web2.0 的推进，HTML 5 崭露头角，出现了更多、更强大的 API  供 JavaScript 调用

CommonJS 的三个核心变量：exports 记录当前模块导出的变量，module 记录当前模块的详细信息，require 进行模块的导入

在 Node 中，每个文件模块都是一个对象，会有相应的编译和执行，定位到具体的文件后，Node 会新建一个模块对想，然后根据路径载入并编译，对于不同的文件扩展名，其载入方法也有所不同（比如 js 文件会用一个函数包裹再编译，json 用 fs 模块读取文件，然后用 JSON.parse 解析后返回结果）

Node 对获取的 JavaScript 文件内容进行了头尾包装，`function(exports, require, module, __filename __dirname) { }`

包的出现，则是在模块的基础上进一步组织 JavaScript 代码：

![包组织模块示意图](../image/%E5%8C%85%E7%BB%84%E7%BB%87%E6%A8%A1%E5%9D%97%E7%A4%BA%E6%84%8F%E5%9B%BE.png)

CommonJS 的包规范的定义也十分简单，它由包结构和包描述（package.json）两个部分组成，前者用于组织包中的文件，后者用于描述包的相关信息

全局模式安装并不是将一个模块包安装为一个全局包的意思，并不意味着可以从任何地方通过 require 来引用它，事实上，全局模式安装的所有模块包都安装进了一个统一的目录下，这个目录可以推算出来

前后端 JavaScript 分别在 HTTP 的两端，它们扮演的角色并不同。浏览器端的 JavaScript 需要从同一个服务器端发送到多个客户端执行，而服务器端 JavaScript 则是相同的代码需要多次执行，前者的瓶颈在于带宽，后者的瓶颈在于 CPU 和内存等资源。