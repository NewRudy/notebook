# 图说设计模式

[github](https://design-patterns.readthedocs.io/zh_CN/latest/)

[toc]



## 目标

![image-20210913213527415](http://111.229.14.128:9001/wutian/Cimage-20210913213527415.png)

看懂UML类图和时序图 $\rightarrow$ 创建型模式 $\rightarrow$ 结构性模式 $\rightarrow$ 行为型模式

# 看懂UML类图和时序图

![_images/uml_class_struct.jpg](http://111.229.14.128:9001/wutian/Cuml_class_struct.jpg)

- 车的类图结果是 $<<abstract>>$ ，表示车是一个抽象类
- 车有两个继承类：小汽车和自行车，它们之间的关系是实现关系，关系用一个带虚线的空心箭头表示
- suv继承小汽车，它们之间的关系是泛化关系，关系用一个带实线的空心箭头表示
- 轮胎和发动机组成小汽车，是一种组成关系，用带实线的实心箭头表示
- 学生上学要用到自行车，是一种依赖关系，用带虚线的箭头表示
- 学生聚合成一个班级，是一种聚合关系，用带实心的空心箭头表示
- 学生有身份证，是一种关联关系，用实线表示

### 泛化关系（generalization）

类的集成结构表现在 UML 中： 泛化（generalize）和实现（realize）

集成关系是 $is-a$ 的关系，如果两个对象之间可以用 $is-a$来表示，就是继承关系：自行车是车

泛化关系用一条带实线的空心箭头实线

关系用一个带虚线的空心箭头表示

![_images/uml_generalization.jpg](http://111.229.14.128:9001/wutian/Cuml_generalization.jpg)

最终代码中，泛化关系表现为继承非抽象类

### 实现关系（realize）

实现关系用一个带空心箭头的虚线表示

eg：”车”为一个抽象概念，在现实中并无法直接用来定义对象；只有指明具体的子类(汽车还是自行车)，才 可以用来定义对象（”车”这个类在C++中用抽象类表示，在JAVA中有接口这个概念，更容易理解）

![_images/uml_realize.jpg](http://111.229.14.128:9001/wutian/Cuml_realize.jpg)

最终代码中，实现关系表现为继承抽象类

### 聚合关系（aggregation）

聚合关系用一条带空心菱形箭头的直线表示，如下图表示 A 聚合到 B 上，或者说 B 由 A 组成：

![_images/uml_aggregation.jpg](http://111.229.14.128:9001/wutian/Cuml_aggregation.jpg)

聚合关系用于表示实体对象之间的关系，表示整体由部分构成的语义，eg：一个部门由多个员工组成

与组合关系不同的是，整体和部分不是强依赖，即使整体不存在了，部分依然是存在的，eg：部门撤销了，人员不会消失，他们依然存在

### 组合关系（composition）

组合关系用一条带实现菱形箭头表示，如下图表示 A 组成 B：

![_images/uml_composition.jpg](http://111.229.14.128:9001/wutian/Cuml_composition.jpg)

与聚合关系一样，组合关系同样表示整体由部分存在的语义：公司由很多个部门存在

但是组合关系hi是一种强依赖关系，如果整体不存在了，则部分也不存在了：公司破产了，部门也无了

### 关联关系（association）

关联关系用一条直线表示，它表示不同类的对象之间的结构关系，它是一种静态关系，通常与运行状态无关，一般由常识等因素决定的，它一般用来定义对象之间静态的，天然的结构，所以，关联关系是一种“强关联”的关系：乘车人和车票

关联关系默认不强调方向，表示对象之间都相互知道，如果特别强调方向，如下图，表示 A 知道 B， B 不知道 A

![_images/uml_association.jpg](http://111.229.14.128:9001/wutian/Cuml_association.jpg)

在最终代码中，关联对象通常是以成员变量的形式实现的

### 依赖关系（dependency）

依赖关系用一个带箭头的虚线表示，如下图表示 A 依赖于 B；他描述一个对象在运行期间会用到另一个对象的关系

![_images/uml_dependency.jpg](http://111.229.14.128:9001/wutian/Cuml_dependency.jpg)

与关联关系不同的是，它是一种临时的关系，通常在运行期间产生，并且随着运行时的变化，依赖关系也可能发生变化

显然，依赖有方向，双向依赖是一种非常糟糕的结构，我们总是应该保持单向依赖，杜绝双向依赖的产生

在最终代码中，依赖关系体现为为类的构造方法及类方法的传入参数，箭头的指向表示调用关系，依赖关系处理临时知道对方外，还是使用对方的方法和属性

### 时序图（sequence diagram）

为了展示对象之间的交互细节，都会用到时序图

时序图（sequence diagram）是显示对象之间交互的图，如果这些对象是按时间顺序排列的，时序图显示的是参与交互的对象及其对象之间消息交互的顺序

时序图包括的建模元素有：对象（Actor）、生命线（Lifeline）、控制焦点（Focus of control）、消息（Message）等

## 创建型模式（creational pattern）

创建型模式对类的实例化过程进行了抽象，能够将软件模块中对象的创建和对象的使用分离。为了使软件的结构更加清晰，外界对于这些对象只需要知道它们共同的接口，而不清楚其具体的实现细节，使整个系统的设计更加符合单一职责原则。

包含模式：简单工程模式、工厂方法模式、抽象工厂模式、建造者模式、原型模式、单例模式

### 简单工厂模式（simple factory pattern）

模式定义：属于类创建型模式，在简单工厂模式中，可以根据参数的不同返回不同类的实例。简单工厂模式专门定义一个类来负责创建其它类的实例，被创建的实例通常都是具有共同的父类

模式结构：

- 工厂角色（factory）： 工厂角色负责实现创建所有实例的内部逻辑
- 抽象产品角色（product）：抽象产品角色是创建所有对象的父类，负责描述所有实例所共有的公共接口
- 具体产品角色（concreteProduct）：具体产品角色是创建目标，所有创建的对象都充当这个角色的某个具体类的实例

![../_images/SimpleFactory.jpg](http://111.229.14.128:9001/wutian/SimpleFactory.jpg)

![../_images/seq_SimpleFactory.jpg](http://111.229.14.128:9001/wutian/seq_SimpleFactory.jpg)

```c++
#include "Factory.h"
#include "ConcreteProductA.h"
#include "ConcreteProductB.h"

Product* Factory:createProduct(string proname) {
    if("A" === proname){
        return new ConcreteProductA();
    } else if("B" === proname) {
        return new ConcreteProductB();
    }
    return NULL;
}
```

**模式分析**

- 将对象的创建和对象本身业务处理分离可以降低系统的耦合度，使得两者修改起来都相对容易
- 在调用工厂类的工厂方法时，由于工厂方法是静态方法，使用起来很方便，可以通过类名直接调用，而且只需要传入一个简单的参数即可，在实例开发中，还可以在调用时将所传入的参数保存在XML等格式的配置文件中，修改参数时无须修改任何源码
- 简单工厂问题的最大问题在于工厂类的职责相对过重，增加新的产品需要修改工厂类的判断逻辑，这一点与开闭原则是相违背的
- 简单工厂模式的要点在于：当你需要什么，只需要传入一个正确的参数，就可以获取你需要的对象，而无需知道其创建细节

**优点**

- 工厂类含有必要的判断逻辑，可以决定在什么时候创建哪一个产品类的实例，客户端可以免除直接创建产品对象的责任，而仅仅“消费”产品；简单工厂模式通过这种做法实现了对责任的分割，它提供专门的工厂类用于创建对象
- 客户端无须知道所创建的具体产品类的类名，只需要知道具体产品类所对应的参数即可，对于一些复杂的类名，通过简单工厂模式可以减少使用者的记忆量
- 通过引入配置文件，可以在不修改任何客户端代码的情况下更换和增加新的具体产品类，在一点程度上提高了系统的灵活性

**缺点**

- 由于工厂类集中了所产品创建逻辑，一点不能正常工作，整个系统都要受到影响
- 使用简单工厂模式将会增加系统中类的个数，在一定程度上增加了系统的复杂度和理解难度
- 系统扩展困难，一旦添加新产品就不得不修改工厂逻辑，在产品类型较多时，有可能造成工厂逻辑过于复杂，不利于系统的扩展和维护

**总结**

- 创建型模式对类的实例化过程进行了抽象，能够将对象的创建与对象的使用过程分离。
- 简单工厂模式又称为静态工厂方法模式，它属于类创建型模式。在简单工厂模式中，可以根据参数的不同返回不同类的实例。简单工厂模式专门定义一个类来负责创建其他类的实例，被创建的实例通常都具有共同的父类。
- 简单工厂模式包含三个角色：工厂角色负责实现创建所有实例的内部逻辑；抽象产品角色是所创建的所有对象的父类，负责描述所有实例所共有的公共接口；具体产品角色是创建目标，所有创建的对象都充当这个角色的某个具体类的实例。
- 简单工厂模式的要点在于：当你需要什么，只需要传入一个正确的参数，就可以获取你所需要的对象，而无须知道其创建细节。
- 简单工厂模式最大的优点在于实现对象的创建和对象的使用分离，将对象的创建交给专门的工厂类负责，但是其最大的缺点在于工厂类不够灵活，增加新的具体产品需要修改工厂类的判断逻辑代码，而且产品较多时，工厂方法代码将会非常复杂。
- 简单工厂模式适用情况包括：工厂类负责创建的对象比较少；客户端只知道传入工厂类的参数，对于如何创建对象不关心。