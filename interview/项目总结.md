# 项目总结

## 1. 3D WebGIS

Cesium + echart + Jquery + bootstrap 

1. 坐标转换，js 怎么处理精度问题

[js 数字精度](https://segmentfault.com/a/1190000021684144)

JavaScript 内部，所有数字都是以 64 位浮点数形式储存，浮点数分为三部分：符号位，指数位，尾数位置

![64w.jpg](https://segmentfault.com/img/bVbC815)

<div align='center'>js 存储数字</div>

精度产生的原因：0.1 0.2 这种转化为二进制码是有误差的，尾数是一个不断循环的数，但是浮点数的尾数只有 52 位，省略了一部分，所以就会产生误差；其次是在对接操作的时候会损失掉一部分尾数

toPrecision 和 toFixed 都是把数字转换为字符串展示，在计算过程中不要使用

- `toPrecision`是处理精度，精度是从左至右第一个不为0的数开始数起。
- `toFixed`是小数点后指定位数取整，从小数点开始数起。

如果用 toFixed 来做四舍五入会有bug，如：`1.005.toFixed(2)`返回的是`1.00`而不是`1.01`，原因：`1.005`实际对应的数字是`1.00499999999999989`，在四舍五入时全部被舍去！ 不过 `(1.005).toPrecision(4) ===> 1.005`，可以自己写一套字符串逻辑去处理：

```javascript
if(!Number.prototype._toFixed) {
  Numger.prototype._toFixed = Number.prototype.toFixed
}
Number.prototype.toFixed = function(n) {	// 加上一个非常小的数就解决了
  return (this + 3e-16)._toFixed(n)
}
```

误差主要产生在进制转化和浮点数运算的对阶操作，整数由于尾数后面全是 0 ，同时转为二进制数就没有误差，所以可以将数字全部转为整数，计算完再转化为小数：

```javascript
function add(num1, num2) {
  const num1Digits = (num1.toString().split('.')[1] || '').length
  const num2Digits = (num2.toString().split('.')[1] || '').length
  const baseNum = Math.pow(10, Math.max(num1Digits, num2Digits))
  return (num1 * baseNum + num2 * baseNum) / baseNum
}
```

有现成的库 mathjs，原理是不走浮点数这套，将数字转换为字符串，自己实现运算逻辑

2. 地图渲染速度的问题

不使用 Vue 的原因，速度慢，会产生数据劫持，如果将 cesium.js 初始化的地图对象保存在 Vue 实例上，地图对象会经常更新，数据更新了 DOM 也要同时更新，会十分的卡顿，所以就用纯 js 写的，然后将地图对象绑定到 window 上了

但是地图渲染过程中还是有明显的卡顿，最后发现是滚动条的出现改变了页面主体的宽度，容器宽度的变化导致 Cesium 触发它的 resize 操作，然后长时间的 JS 阻塞导致了卡顿，解决办法：`overflow: hidden`

## 2. OpenGMS 门户

1. 主要是第一次接触 Spring 了







## 数据容器后端

1. 较大数据的存储，一个文件夹的存储，同时复制太多文件会崩掉，第一次使用了并发，当时是复制一个文件夹的数据，同时开了 10 个线程来复制文件

在 Node 中我们可以十分方便的利用异步和并行来提升我们的业务速度，但是并发量过大，我们的服务器却可能吃不消，需要限制并发量。原理是通过队列限制

2. child_process spawn 终端输出过多会导致栈溢出，但是又没有错误提示

使用 spawn 的时候，子进程有太多的日志输出，导致该子进程卡在那里，没有正常或者异常的退出，文件也被占用着，最坑的是一点提示都没有

exec 的 option 默认为：

```json
{ 
    encoding: 'utf8',
    timeout: 0, /*子进程最长执行时间 */
    maxBuffer: 200*1024,  /*stdout和stderr的最大长度*/
    killSignal: 'SIGTERM',
    cwd: null,
    env: null
  }
```

注意 maxBuffer 这个参数，如果 stdout 的值超过 200 k 的时候就会杀死进程，其实spawn 表现的更差，当 spawn 的子进程的 stdout 更多的时候会出现我前文说过的问题，文章中说 spawn 没有 maxBuffer 限制，但是我个人感觉还是有 maxBuffer 的类似限制。exec 在使用便捷上要超过 spawn，且执行速度上也相差无几，但是这种便携性要付出一定的代价。在exec的options中，有一项是 maxBuffer，如果执行的 command 输出超出了这个长度，不管是采用回调函数的方式，还是emit data 事件方式传递结果，都会抛出 maxBuffer exceeded异常，并且杀死子进程

3. mongo  一个记录不能超过 16 M



4. 异步的写法，什么时候 promise，什么时候 await