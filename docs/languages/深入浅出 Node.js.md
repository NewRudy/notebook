# 深入浅出 Node.js

## 1. Node 简介

Node 作者 Ryan Dahl 刚开始只是想设计高性能，Web 服务器，需要有两个特点：事件驱动，非阻塞 I/O，但是后来发展成为一个强制不共享任何资源的单线程、单进程系统，包含十分适宜网络的库，为构建大型分布式应用程序提供基础设施，其目标也是成为一个构建快速、可伸缩的网络应用平台

浏览器通过时间驱动服务界面上的交互，Node 通过事件驱动 I/O 服务

Web Worker $\Leftrightarrow$ child_process：Web workder 通过创建工作线程来进行计算，已解决 JavaScript 大计算阻塞 UI 渲染的问题，工作线程为了不阻塞主线程，通过消息传递的方式来传递运行结果。child_process 也用了同样的方式 ，Node 可以通过将计算分发到各个子进程，可以将大量计算分解掉，然后再通过进程之间的事件消息来传递结果，这可以很好地保持应用模型的简单和低依赖

Node 性能还行，应该也擅长 CPU 密集型，但是有个最主要的挑战：由于 JavaScript 单线程的原因，如果有长时间运行的计算（比如大循环），将会导致 CPU 时间片不能释放，是的后续 I/O 无法发起。但是适当调整大型运算任务为多个小任务，使得运算能够适时释放，就能很好的运行

Node 的应用：

- 前后端语言的统一
- Node 带来的高性能 I/O 用于实时应用
- 并行 I/O 使得使用者能更高效地利用分布式环境
- 并行 I/O，有效利用稳定接口提升 Web 渲染能力
- 云计算平台提供 Node 支持

## 2. 模块支持

### CommonJS

node 可以处理 ES6 模块了，[处理教程](https://www.ruanyifeng.com/blog/2020/08/how-nodejs-use-es6-module.html)，CommonJS 模块和 ES6 模块除了语法的区别，最大的区别是同步和异步了，ES6 模块有一个独立的静态解析阶段，依赖关系会在这个阶段完成，并且最底层的模块第一个执行。node 要求 ES6 模块使用 .mjs 后缀名，或者再 package 中设置。

CommonJs 规范为 JavaScript 制订了一个美好的愿景：希望 JavaScript 能够在任何地方运行。刚开始的 node 的模块就是使用的 CommongJS 模块规范

### 模块实现

node中引入模块需要经历的 3 个步骤：

1. 路径分析：优先从缓存加载，然后是核心模块，再然后是以路径形式的文件模块，最后是自定义模块
2. 文件定位：文件扩展名分析（.js，.node，.json），目录分析和包（index）
3. 编译执行：创建一个模块对象，然后根据路径载入并编译，成功后将其路径作为索引缓存下来

编译和执行是最后一步，node会创建一个模块对象，会根据路径载入并编译，每个编译成功的都会将文件路径缓存到Module._cache 上，模块编译

- js文件：通过 fs 模块同步读取文件后编译执行
- .node 文件：通过 dlopen() 方法加载最后编译生成的文件
- .json文件：fs读取并 JSON.parse() 得到对象

JavaScript 模块的编译：通过在头部添加 `(function (exports, require, module, __filename, __dirname)){}` 进行了包装，这样每个模块文件之间进行了作用域隔离，包装后的代码通过函数执行，返回一个具体的 function 对象。在执行后，模块的 exports 属性被返回给了调用方

C/C++ 模块的编译：其实 .node 的模块文件不需要编译，因为它是编写 C/C++ 模块之后编译生成的，所以只有加载和执行的过程

JSON 文件的编译：fs 模块同步读取 JSON 文件内容之后，调用 JSON.parse() 得到对象

### 模块编译

Node 的核心模块分为 C/C++ 编写（放在 src 目录）的和 JS 编写的（放在 lib 目录）两部分，在编译所有的 C/C++ 文件之前，需要将所有的 JavaScript 模块文件编译成 C/C++ 代码。

JavaScript 核心模块的编译过程：

1. 转存 C/C++：node 采用了 V8 附带的 js2c.py 工具，将所有内置的 JavaScript 代码转换进 C++ 里的数组（其实就是指针了，长度加一）
2. 编译 JavaScript 核心模块：核心模块也需要包装，但是核心模块是从内存中加载的，并缓存到 NativeModule._cache

内建模块的优势：由 C/C++ 编写，性能上优于脚本语言，其次在执行文件编译时候，它们被编译成二进制文件，一旦 Node 开始执行，它们会被直接加载进内存中，可以直接运行。内建模块也是统一放进了一个数组里面，可以很方便的取出（其实就是指针了）

内建模块的导出：Node 的所有模块存在着一种依赖层级关系，文件模块可能依赖核心模块，核心模块可能依赖内建模块，文件模块一般调用核心模块，核心模块封装了内建模块。内建模块通过内部变量或者方法导出，共外部的 JavaScript 核心模块调用的

C/C++ 核心模块的引入流程：为了符合 CommonJS 的模块规范，从 JavaScript 到 C/C++ 的引入过程是很复杂的，要经历 C/C++ 层面的内建模块的定义、JavaScript 核心模块的定义和引入和 文件模块的定义和引入

因为模块与模块之间仍然是散列在各地的，相互之间不能直接引用，而在模块之外，包和 NPM 则是将模块联系起来的一种机制

### 前后端公用模块

JavaScript 在 Node 出现后，比别的编程语言多了一个优势，就是一些模块可以在前后端共用，但是前后端环境是略有差别的

模块的侧重点：浏览器端的代码需要经历从一个服务器分发到多个浏览器端执行，服务端的代码则是同一代码多次执行，前者的瓶颈是带宽，后者的瓶颈则在于 CPU 和内存等资源。Node 采用同步的方式加载，但是前端如果也采用同步的方式加载，会给用户体验造成很大的问题，最终 AMD 规范在应用场景中胜出

AMD 规范是 CommonJS 模块规范的一个延伸，它需要用 define 来明确定义一个模块，而在 Node 实现中是隐式包装的

CMD 规范与 AMD 规范的主要区别在于定义模块和依赖引入的部分，AMD 需要在声明模块的时候指定所有的依赖，通过形参传递依赖到模块内容中；与 AMD 模块规范相比，CMD 模块更接近于 Node 对 CommonJS 规范的定义

## 3. 异步 I/O

Node 的基调：异步 I/O，事件驱动，单线程

### 为什么要异步  I/O

用户体验：I/O 是昂贵的，分布式 I/O 更是昂贵的

资源分配：单线程模型会因为阻塞 I/O 导致资源得不到有效利用，多线程又因为编程中的死锁、状态同步等问题然开发者头疼；Node 给出的方案是使用单线程，远离多线程的死锁，状态同步的问题；利用异步 I/O，远离阻塞

### 异步  I/O 实现现状

操作系统对于 I/O 只有两种方式：阻塞与非阻塞，调用阻塞 I/O 时，应用程序需要等待系统内核层面完成所有操作；非阻塞 I/O 则不带数据直接返回，要获取数据，还需要通过文件描述符再次读取

非阻塞IO技术：read（轮询），select（数组事件状态），poll（链表事件状态），epoll（休眠，真实利用了事件通知，执行回调的方式）

尽管 epoll 已经利用了事件来降低 CPU 的耗用，但是休眠期间 CPU 是几乎闲置的，利用率不够。期望的完美的异步 I/O 应该是应用程序发起非阻塞调用，无需通过遍历或则事件唤醒等方式轮询，可以直接处理下一个任务，只需在 I/O 完成后通过信号或回调将数据传回应用层即可

### 现实的异步 I/O

现实要比理想骨感一些，场景不应该限定在单线程的情况。线程池模拟异步 I/O：通过让部分线程进行阻塞 I/O 或则非阻塞 I/O加轮询的方式完成数据的获取，让一个线程进行计算处理，通过线程之间的通信将 I/O 得到的数据进行传递，这就实现了异步 I/O

Node 是单线程的，这里的单线程仅仅只是 JavaScript 执行在单线程中罢了，在 Node 中，内部完成 I/O 任务的另有线程池

### Node 的异步 I/O

Node 与 浏览器的 Event Loop 差异：在浏览器环境下，microtask 的任务队列是每个 macrotask 执行完之后执行的；而在 Node.js 中，microtask 会在事件循环的各个阶段之间执行，也就是一个阶段执行完毕，就回去执行 microtask 队列的任务

事件循环：node 的执行模型，正是它使得回调十分普遍。在进程启动时，Node 便会创建要给类似与 while(true) 的循环，每次执行一次循环体的过程称之为 trick，每次 trick 的过程就是查看是否有事件待处理，有事件就取出事件，如果存在关联回调，就执行回调

事件循环是一个典型的生产者/消费者模型，异步 I/O、网络请求等则是事件的生产者，源源不断的为 Node 提供不同类型的事件，这些事件被传递到对应的观察者（文件I/O观察者，网络 I/O 观察者），事件循环则从观察者那里取出事件并处理

对于 Node 中的异步 I/O 调用而言，回调函数却不由开发者来调用，从 JavaScript 发起调用到内核执行完成 I/O 操作的过渡过程中，存在一种请求对象的中间产物，所有的状态都保存在这个对象中，包括送入线程池等待执行以及 I/O 操作完毕后的回调处理

node 异步I/O构成要素：异步调用、线程池、I/O观察者、事件循环

![node的异步流程](../image/node%E7%9A%84%E5%BC%82%E6%AD%A5%E6%B5%81%E7%A8%8B-16481900291561.png)

<div align='center'>node 异步I/O流程</div>

### 非 I/O 的异步 API

Node 中还存在一些与 I/O 无关的异步 API：setTimeout()、setInterval()、setImmediate()、process.nextTick()

定时器的实现原理和异步 I/O 比较像，但是不需要线程池的参与，调用定时器会被插入到定时器观察者内部的一个红黑树中。每次Trick执行时，会从该红黑树中迭代取出定时器对象，检查他是否超时，超时就形成一个时间。但是定时器的问题在于它并非是精确的，尽管事件循环十分快，但是如果某次循环占用的时间较多，那么下次循环时，也许已经超时很久了

process.nextTrick() 会将回掉函数放入队列中，下一路 Trick时取出执行。由于时间循环自身的特点，定时器精确度不够，并且采用定时器需要动用红黑树，创建定时器对象和迭代等操作，所以 `setTimeout(fn, 0)` 的方式是较为浪费性能的

setImmediate() 方法和 process.nextTrick() 十分类似，但是 process.nextTrick 快于 setImmediate

### 事件驱动

事件驱动架构是建立在软件开发中一种通用模式上的，这种模式称为 发布-订阅 或 观察者模式，在事件驱动架构中，至少有两个参与者：主题（subject）和观察者（observer），主题就像是收音机一样，向有兴趣的观察者进行广播。

node 和浏览器都是一个原理，通过事件循环加事件触发的方式来运作程序，只是对象不一样

典型的服务器模型：

- 同步式：一次处理一个请求，其余的只能等待
- 每进程/每请求：为每个请求启动一个进程，这可以可以处理多个请求，但是资源有限，不具备扩展性
- 每线程/每请求：为每个请求启动一个线程，但是大并发请求的情况下，内存依然会被耗光

每线程/每请求的模式还被 Apache 所采用，但是Nginx 和 Node 都采用了事件驱动的方式处理请求，更为高效

## 4. 异步编程

