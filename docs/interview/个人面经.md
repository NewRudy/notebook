# 个人面经

## 阿里-钉钉

### 一面、电话面（面试，笔试）    3.9 

面试问题（1 小时）

1. 做了哪些项目，项目用到了哪些东西
2. Ajax 为什么不用更新页面了（这个回答的有点懵）
3. Vue拿到数据之后怎么渲染数据的（最近太忙，Vue还没来得及仔细看，这块崩了，还一直问，然后问的一些东西我都答非所问的，也没记住问题，惨败！）
4. CSS 选择器权重（这个背了，看我vue回答的太差的，送我分的）
5. const let var（同上）
6. 写的代码 es6 怎么在浏览器中运行
7. apply，call，bind
8. js 有哪些自己觉得算是理解的点（我giao，这真是送命题啊，我说了之后把我问死的意思吗）
9. Cookie 有哪些属性
10. 为什么有些网站不消除 Cookie就一直能登录（我就回答了一句，不消除发送的时候自动把Cookie也包进去了，感觉回答的很简单，，，）
11. 实现历史回退前进（我回答了快照）
12. TS VS JS （只回答了强弱类型，然后胡扯了一下）
13. 为啥决定走前端了
14. 前端占你学习比重有多大，可以多了解一点底层的东西（当时就觉得凉凉了）
15. 现在觉得前端有哪些不好的问题，最想做啥（好的我准备了，不好的地方还真没想到）

笔试（4 选 3，1小时）

1. 操作DOM（这个自己就很少写，直接pass）
2. 递归将一个对象数组排序（这个有一点问题，网页的编译器判断 Array.isArray 这个函数不能用，然后我就不知道怎么判断这个变量是不是一个数组了）
3. 比较版本号（正则用的有点不熟练啊，其它没啥问题）
4. 节流函数

### 二面、电话面    3.26

都是面试，全程大概将近一小时，主要以项目为主，前端的一些原理为辅助（又在原理上崩了，giao）

1. 讲项目（然后我就讲了自己做的项目，nodejs + vue + mongo + websocket )
2. 具体问了表的设计，项目解决了什么问题，用了什么技术
3. 项目难点，亮点，我说的是 I/O 压力过大，服务器的文件描述符很快用光，会吃不消，并且容易 monog 中一条记录会超级大，超过了 16 mb 的限制，然后childprocess 调子进程会有的一些bug，资源管理的设计还不错等等
4. 问了实验室的一些事
5. 提出项目中的一些场景让我怎么解决，比如问了怎么实现将删除的文件或文件夹复原，也就是实现一个回收站的功能，我回答的是用栈的思想，再创建一个类似回收站的临时文件夹，巴拉巴拉的讲了一堆，但是面试官觉得用版本号可以更好的解决，栈只是一个线性的结构
6. vue2 的响应式用了 defineProperty，vue 3 用了 props，为什么（这个回答的很差，，，）
6. v-if 与 v-for 为什么不推荐同时使用
6. v-for 为什么要加 key
7. vue 路由跳转的时候怎么更新渲染的（这个也回答的很差）
8. 用过 React 的 hook 吗（，，，）
9. css 掌握程度（，，，）
10. 用的的组件库里面觉得最好的组件是啥（这个我觉得组件不都是常规的吗，说了一个 react-color-palette，至于什么原因就说的很主观，没说技术上的）
11. 问我还有什么要展示的吗（当时没想好，答得不好，想想应该说说算法和自己对新技术的探索 :cry:） 
12. 能实习吗，有没有面其它公司，等等一些常规的问题

## 七牛云

### 一面、电话面    5.10

1. 你的专业和软件工程有什么区别（，，，）
2. 虚拟内存和物理内存的区别（第一个问题就把我给整懵了）
3. 了解 CDN（内容分发网络） 吗（服务器网络，尽可能快的交付内容）
4. 块元素怎么行内排列
5. vue 和 react 的区别，优势
6. 平时的编程环境是啥样的，会用哪些东西
7. header 用那些请求头（当时无语了，没回答好，应该通用、请求、响应这种分类来答的）
8. Cookie 等缓存方面的知识
9. 你为什么选择前端等等问题
10. url 的参数转一个对象，但是优化的时候要我用 reduce 方法（这个方法没有写过，就不知道怎么写了，然后这个编译器不仅没有提示，连反括号都没有，极其难用）

```js
function urlToObj(input) {
  let tempStr = input ? input.split('?')[1] : '';
  let tempParams = tempStr ? tempStr[1].split('&') : [];
  let obj = {}, key, value, temp;
  // 写法 1：for 循环
  for(let i = 0; i < tempParams.length; ++i) {
    temp = tempParams[i].split('=');
    key = temp ? temp [0] : '';
    value = temp ? temp [1] : '';
    if(key.length) {
      if(obj.hasOwnProperty(key)) {
        if(!Array.isArray(obj[key])) {
          obj[key] = [obj[key]];
        }
        obj[key].push(value);
      } else {
        obj[key] = value;
      }
    }
  }
  // 写法 2： map 函数
  tempParams.map(item => {
    temp = item.split('=');
     key = temp ? temp [0] : '';
    value = temp ? temp [1] : '';
    if(key.length) {
      if(obj.hasOwnProperty(key)) {
        if(!Array.isArray(obj[key])) {
          obj[key] = [obj[key]];
        }
        obj[key].push(value);
      } else {
        obj[key] = value;
      }
    }
  })
  // 写法 3： reduce 函数
  tempParams.reduce((prev, item) => {
    key = item.split('=')[0];
    value = item.split('=')[1];
    if(key.length) {
      if(prev.hasOwnProperty(key)) {
        if(!Array.isArray(prev[key])) {
          prev[key] = [prev[key]];
        }
        prev[key].push(value)
      } else {
        prev[key] = value;
      }
    }
  }, obj)
  
  return obj;
}
```

