# 剑指offer

[刷题网址](https://leetcode-cn.com/problem-list/e8X3pBZi/)

买了书，总共15章节的内容，共150题，Java 和 JavaScript 两种代码都跟着敲下来了，想看写的代码的打开网址看提交记录就行

## 1. 整数

整数在计算机中使用二进制形式表示，每位不是 0 就是 1。位运算是对二进制整数的运算，包括与运算、或运算、非运算、异或运算、左移运算和右移运算。只有深刻理解每种位运算的特点才能在需要的时候灵活地应用合适的位运算解决相应的问题

- 负数转正数存在问题，所以可以将正数转为负数解决问题
- 普通的加法可能导致溢出
- `i & (i - 1)` 可以将整数最右边的 1 变成 0 
- 如何判断只出现 1 次的数字，其实就是进制上的每一位整除
- 进制来解决布尔哈希的问题，可以少几十次的运算

## 2. 数组

由于数组中的元素再内存中的地址是连续的，所以可以以 O(1) 的时间随机访问

双指针是解决数组相关的常用技术。如果数组是排序的，利用双指针可以用 O(n) 的时间再数组中找出两个和为给定值的数字。如果数组中的所有数字都是整数，那么应用双指针技术就可以用 O(1) 的辅助空间找出和为给定值的子数组

如果关于子数组的数字之和的面试题并没有限定数组中的所有数字都是正数，那么可以尝试从第 1 个数字开始累加数组中前面若干数字之和，两个累加的和的插值对应一个子数组的数字之和。这种累加数组中前面若干数字之和的思路，不仅适用与一维数组，也适用于二维数组

- 为了解决数组空间效率不高的问题，人们又设计实现了动态数组
- 指针是一个相对宽泛的概念，是能定位数据容器中某个数据的手段，在数组中它实际上是数字的下标
- 3 数之和其实是 2 数之和的加强版，如果输入的数组是排序的，就可以先固定一个数字 i ，然后在排序数组中查找和为 -i 的两个数字
- 最短子数组的题目有点类似于滑动窗口
- 只要保持指针 P2 的不动，向右移动 P1 形成的所有子数组都满足条件，其实就是两个指针内部的数字就是找到的子数组个数
- 从头到尾逐个扫描数组中的数字时求出前 i 个数字之和，并且将之保存下来。数组的前 i 个数字之和记为 x，如果存在一个 j(j < i) ，数组的前 j 个数字之和为 x- k，那么数组中从第 i + 1 个数字开始到第 j 个数字结束的子数组之和就为 k

## 3. 字符串

变位词和回文是很有意思的文字游戏，在与字符串相关的算法面试题中，它们出现的频率很高。如果两个字符串包含的字符及每个字符出现的次数相同，只是字符出现的顺序不同，那么它们就是一组变位词。通常可以用一个哈希表来统计每个字符出现的次数，有了哈希表就很容易判断两个字符串是不是一组变位词

通常可以用两个指针来判断一个字符串是不是回文，要么指针从两端开始向中间移动，要么两个指针从中间向两端移动

- 由于每次对 String 实例进行修改将创建一个新的 String 实例，因此如果连续多次对 String 进行修改将创建多个新的 String 实例，不必要的内存开销较大。所以可以创建一个 StringBuilder 实例，因为它能容纳修改后的结果
- 如果两个指针之间的子字符串中包含重复的字符，则可以向右移动第 1 个指针，删除子字符串中最左边的字符。如果删除最左边的字符之后仍然包含重复的字符，则继续向右移动第 1 个指针删除最左边的字符
- 使用 Java 中的类型 HashMap，不使用数组模拟，可以非常方便地判断一个字符在字符 t 中是否出现

## 4. 链表

```java
public class ListNode{
  public int val;
  public ListNode next;
  public ListNode(int val) {
    this.val =  val;
  }
}
```

链表是一种常见的基础数据结构。在链表中，每个节点包含指向下一个节点的指针，这些指针把节点连接成链状结构。链表能实现灵活的内存动态管理，与数组相比，链表更适合用来存储一个大小动态变化的数据集。如果需要在一个数据集中频繁地添加新的数据并且不需要考虑数据的顺序，那么可以用链表实现这个数据集。

- 输入的链表为空，或者操作可能会产生新的头节点，这些是容易忽视的测试用例。如果合理应用哨兵节点，就不再单独处理这些特殊的输入，从而杜绝由于忘记处理这些特殊输入而出现 bug 的可能性
- 双指针可以根据两个指针不同的移动方式细分成两种方法：1. 前后双指针，经典应用是查找链表倒数第 K 个节点；2. 快慢双指针，找到链表中间节点
- 反转链表是其它很多解法的基础
- 回文链表的时候考虑使用栈
- 双向链表改变指针的时候慢一点，保证指针指向了正确的位置，循环链表的时候需要考虑死循环

## 5. 哈希表

- 哈希表最大的优点是高效，在哈希表中插入、删除或查找一个元素都只需要 O(1) 的时间，因此哈希表经常被用来优化时间效率
- 在 Java 中，哈希表有两个类型与之对应，即 HashSet 和 HashMap，如果哈希表只有一个值，就用 HashSet：add，contains，remove，size；如果每个值都存在一个 值到另一个值的映射，就用 HashMap：containsKey，get，getOrDefault，put，putIfAbsent，remove，replace，size
- 如果对数据集中的元素排序能够有助与解决问题，那么用 TreeSet 或 TreeMap 可能更合适；如果需要知道一个动态数据中的最大最小值，那么堆的效率可能更好；如果根据前缀进行单词查找，那么用前缀树可能更好
- 设计哈希表的 3 个要点：1. 为了快速确定一个元素在哈希表中的位置，可以使用一个数组，元素的位置为它的哈希值除以数组长度的余数。由于多个哈希值不同的元素可能会被存入同一位置，数组的每个位置都对应一个链表，为了确保链表不会太长，就需要计算哈希表中元素的数目与数组长度的比值，当这个比值超过某一个阈值时，就对数组进行扩容并把哈希遍中的所有元素重新分配位置
- 在链表中做顺序扫描的时间复杂度为 O(n)，链表越长查找需要的时间越长。这就违背了设计哈希表最重要的初衷：存入和读取一个元素的时间复杂度为 O(1)
- 从数组中用 O(1) 的时间删除一个数字要麻烦一点，需要先从哈希表中得到需要删除的数字的下标，但不能直接把数字删除。这是因为待删除的数字不一定位于数组的尾部。为了避免在数组中删除数字的时候移动数据，可以把被删除的数字和数组尾部的数字交换，再删除数组最后的数字
- 设计最少使用缓存需要结合哈希表和双向链表的特点。哈希表的键值就是缓存的键，哈希表的值为双向链表中的节点，每个节点都是一个键值对
- 如果只考虑用英文字母，则用数组模拟哈希表；如果考虑非英文字母，则用真正的哈希表 HashMap
- 把一组变位词映射到一个单词，键值就是映射后的这个单词，可以考虑通过排序映射
- 如果哈希表的键的数目是固定的，并且数目不会太大，那么也可以用数组来模拟哈希表，数组的下班对应哈希表的键，而数组的值与哈希表的值对应

